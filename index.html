<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prompt Mission Demo â€” Rubber Duck</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, sans-serif; }
    body { margin: 0; background: #0b0f14; color: #e8eef7; }
    header { padding: 18px 20px; border-bottom: 1px solid rgba(255,255,255,.08); }
    header h1 { margin: 0; font-size: 18px; letter-spacing: .2px; }
    header p { margin: 6px 0 0; opacity: .8; font-size: 13px; }
    .wrap { display: grid; grid-template-columns: 520px 1fr; gap: 16px; padding: 16px; max-width: 1200px; margin: 0 auto; }
    .card { background: rgba(255,255,255,.04); border: 1px solid rgba(255,255,255,.08); border-radius: 14px; overflow: hidden; }
    .card .hd { padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,.08); display:flex; align-items:center; justify-content:space-between; }
    .card .hd b { font-size: 13px; letter-spacing:.2px; }
    .card .bd { padding: 14px; }
    canvas { width: 100%; height: 480px; display:block; background: radial-gradient(1200px 600px at 40% 30%, rgba(90,150,255,.20), transparent 60%); }
    .mission { line-height: 1.6; font-size: 14px; }
    .mission .tag { display:inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.10); font-size: 12px; margin-right: 6px; }
    textarea { width: 100%; min-height: 180px; resize: vertical; background: rgba(0,0,0,.25); color: #e8eef7; border: 1px solid rgba(255,255,255,.12); border-radius: 10px; padding: 12px; line-height: 1.5; font-size: 13px; outline: none; }
    textarea:focus { border-color: rgba(120,170,255,.55); box-shadow: 0 0 0 3px rgba(120,170,255,.18); }
    .row { display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px; }
    button {
      background: rgba(120,170,255,.18);
      border: 1px solid rgba(120,170,255,.35);
      color: #e8eef7;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .2px;
      font-size: 13px;
    }
    button:hover { background: rgba(120,170,255,.26); }
    button.secondary { background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.14); }
    button.danger { background: rgba(255,100,120,.14); border-color: rgba(255,100,120,.30); }
    .console {
      margin-top: 12px;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      white-space: pre-wrap;
      line-height: 1.45;
      min-height: 110px;
      color: #d7e3ff;
    }
    .status {
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      font-size: 13px;
    }
    .ok { border-color: rgba(120,255,170,.28); background: rgba(120,255,170,.08); }
    .bad { border-color: rgba(255,120,140,.28); background: rgba(255,120,140,.08); }
    .hint { opacity: .85; font-size: 12px; margin-top: 8px; }
  </style>
</head>
<body>
  <header>
    <h1>Prompt Mission Demo â€” Rubber Duck ğŸ¦†</h1>
    <p>ë¯¸ì…˜: í”„ë¡¬í”„íŠ¸ë¥¼ ìˆ˜ì •í•´ì„œ ì˜¤ë¦¬ê°€ ë¹¨ê°„ ë™ê·¸ë¼ë¯¸(ëª©í‘œ)ê¹Œì§€ í—¤ì—„ì³ ê°€ê²Œ ë§Œë“œì„¸ìš”.</p>
  </header>

  <div class="wrap">
    <section class="card">
      <div class="hd">
        <b>Scene</b>
        <span style="opacity:.8;font-size:12px">ë„¤ëª¨ ì—°ëª» Â· ë¹¨ê°„ ë™ê·¸ë¼ë¯¸ Â· ì˜¤ë¦¬</span>
      </div>
      <div class="bd" style="padding:0">
        <canvas id="sim" width="520" height="520"></canvas>
      </div>
    </section>

    <section class="card">
      <div class="hd"><b>Mission & Prompt Editor</b></div>
      <div class="bd">
        <div class="mission">
          <span class="tag">ë¯¸ì…˜</span>
          <b>â€œí”„ë¡¬í”„íŠ¸ë¥¼ ìˆ˜ì •í•´ì„œ ì˜¤ë¦¬ê°€ ë¹¨ê°„ ë™ê·¸ë¼ë¯¸ê¹Œì§€ í—¤ì—„ì³ ê°€ê²Œ í•˜ì„¸ìš”.â€</b><br/>
          <span class="tag">íŒíŠ¸</span>
          ì¶œë ¥(ëª…ë ¹)ì„ <b>JSON</b>ìœ¼ë¡œ ê°•ì œí•˜ë©´ ì„±ê³µë¥ ì´ ì˜¬ë¼ê°‘ë‹ˆë‹¤.
        </div>

        <div style="height:10px"></div>

        <div class="mission" style="opacity:.9">
          <span class="tag">ì‹œìŠ¤í…œ ê·œì¹™(ê³ ì •)</span>
          ëª¨ë¸ì€ ë°˜ë“œì‹œ <b>ì»¤ë§¨ë“œ JSON</b>ë§Œ ë°˜í™˜í•´ì•¼ í•©ë‹ˆë‹¤.<br/>
          í—ˆìš© ìŠ¤í‚¤ë§ˆ: <code>{"action":"swim_to","target":"red_circle"}</code> ë˜ëŠ” <code>{"action":"wander"}</code>
        </div>

        <div style="height:10px"></div>

        <label style="font-size:12px;opacity:.85">ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸(ì—¬ê¸°ë¥¼ ìˆ˜ì •í•˜ì„¸ìš”)</label>
        <textarea id="prompt"></textarea>

        <div class="row">
          <button id="run">Run â–¶</button>
          <button class="secondary" id="reset">Reset â†º</button>
          <button class="secondary" id="hint">Auto Hint âœ¨</button>
          <button class="danger" id="panic">Duck Panic ğŸŒ€</button>
        </div>

        <div class="status" id="statusBox">
          ìƒíƒœ: ëŒ€ê¸° ì¤‘
          <div class="hint" id="hintLine">Runì„ ëˆ„ë¥´ë©´ â€œì‹œë®¬ë ˆì´ì…˜ëœ LLM ì¶œë ¥â€ì´ ì½˜ì†”ì— í‘œì‹œë©ë‹ˆë‹¤.</div>
        </div>

        <div class="console" id="console">[console] Ready.</div>
      </div>
    </section>
  </div>

<script>
(() => {
  // ===== UI Elements =====
  const canvas = document.getElementById("sim");
  const ctx = canvas.getContext("2d");
  const promptEl = document.getElementById("prompt");
  const consoleEl = document.getElementById("console");
  const statusBox = document.getElementById("statusBox");
  const hintLine = document.getElementById("hintLine");

  const btnRun = document.getElementById("run");
  const btnReset = document.getElementById("reset");
  const btnHint = document.getElementById("hint");
  const btnPanic = document.getElementById("panic");

  // ===== Scene Config =====
  const W = canvas.width, H = canvas.height;

  // Square pond
  const pond = { x: 60, y: 60, size: 400 };

  // Red circle target inside pond
  const target = { x: pond.x + pond.size * 0.78, y: pond.y + pond.size * 0.22, r: 18 };

  // Duck state
  const duck = {
    x: pond.x + pond.size * 0.20,
    y: pond.y + pond.size * 0.78,
    r: 18,
    vx: 0,
    vy: 0,
    wobble: 0,
    mode: "idle", // idle | swim_to | wander | panic
    speed: 1.8
  };

  let animId = null;
  let lastTs = null;
  let runLocked = false;

  // ===== Initial Prompt =====
  const basePrompt =
`ë‹¹ì‹ ì€ DuckPilotì…ë‹ˆë‹¤.
ì•„ë˜ ì¥ë©´ì—ì„œ rubber duckì„ ì¡°ì¢…í•˜ì„¸ìš”.

ì¥ë©´:
- ë„¤ëª¨ë‚œ ì—°ëª»
- ë¹¨ê°„ ë™ê·¸ë¼ë¯¸ (ëª©í‘œ)
- rubber duck

ê·œì¹™:
- ë°˜ë“œì‹œ JSONë§Œ ì¶œë ¥í•˜ì„¸ìš”.
- í—ˆìš© ìŠ¤í‚¤ë§ˆ: {"action":"swim_to","target":"red_circle"} ë˜ëŠ” {"action":"wander"}

ìš”ì²­:
ì˜¤ë¦¬ê°€ ì—°ëª» ì•ˆì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ ì›€ì§ì´ê²Œ í•´ì£¼ì„¸ìš”.
(ë‹¨, ì•„ì§ ëª©í‘œê°€ ë­”ì§€ ëª…í™•íˆ ì“°ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤â€¦)`;

  promptEl.value = basePrompt;

  // ===== Helpers =====
  const log = (msg) => {
    consoleEl.textContent = msg;
  };

  const setStatus = (ok, text, sub = "") => {
    statusBox.classList.remove("ok", "bad");
    statusBox.classList.add(ok ? "ok" : "bad");
    statusBox.firstChild.textContent = `ìƒíƒœ: ${text}`;
    hintLine.textContent = sub;
  };

  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const dist = (ax, ay, bx, by) => Math.hypot(ax - bx, ay - by);

  // ===== "Simulated LLM" =====
  // ë©´ì ‘/ê³¼ì œ ë°ëª¨ìš©: ì‚¬ìš©ìê°€ í”„ë¡¬í”„íŠ¸ë¥¼ ë” ëª…í™•í•˜ê²Œ(ëª©í‘œ/ìŠ¤í‚¤ë§ˆ/ëª…ë ¹) ì“°ë©´
  // ëª¨ë¸ì´ ì˜¬ë°”ë¥¸ ì»¤ë§¨ë“œë¥¼ ë‚´ëŠ” ê²ƒìœ¼ë¡œ "ì‹œë®¬ë ˆì´ì…˜"í•©ë‹ˆë‹¤.
  function simulatedLLM(userPrompt) {
    const p = userPrompt.toLowerCase();

    // 1) ì‚¬ìš©ìê°€ JSON ì»¤ë§¨ë“œë¥¼ ì§ì ‘ ì ì–´ ë„£ì—ˆìœ¼ë©´ ê·¸ê±¸ ìš°ì„  ì‹œë„ (í˜„ì‹¤ì—ì„  ëª¨ë¸ ì¶œë ¥ì´ì§€ë§Œ, ë°ëª¨ì—ì„  í”„ë¡¬í”„íŠ¸ ìˆ˜ì • ê³¼ì œ ëŠë‚Œ)
    const jsonMatch = userPrompt.match(/\{[\s\S]*?\}/);
    if (jsonMatch) {
      try {
        const obj = JSON.parse(jsonMatch[0]);
        if (obj && (obj.action === "swim_to" || obj.action === "wander") ) {
          // targetì´ ë§ìœ¼ë©´ ì„±ê³µ ì»¤ë§¨ë“œë¡œ ê°„ì£¼
          if (obj.action === "swim_to" && obj.target === "red_circle") {
            return { raw: JSON.stringify(obj), cmd: obj, clarity: 0.95 };
          }
          if (obj.action === "wander") {
            return { raw: JSON.stringify(obj), cmd: obj, clarity: 0.70 };
          }
        }
      } catch (_) { /* ignore */ }
    }

    // 2) ëª©í‘œ ì–¸ê¸‰ì´ ì¶©ë¶„íˆ ëª…í™•í•˜ë©´ swim_toë¥¼ ë°˜í™˜í•˜ë„ë¡ ì‹œë®¬ë ˆì´ì…˜
    const mentionsDuck = p.includes("duck") || p.includes("ì˜¤ë¦¬") || p.includes("rubber duck");
    const mentionsTarget = p.includes("red_circle") || (p.includes("ë¹¨ê°„") && p.includes("ë™ê·¸ë¼ë¯¸")) || p.includes("red circle");
    const mentionsSwim = p.includes("swim") || p.includes("í—¤ì—„") || p.includes("ì´ë™") || p.includes("ê°€ê²Œ");
    const enforcesJson = p.includes("json") && (p.includes("ë°˜ë“œì‹œ") || p.includes("only") || p.includes("ë§Œ"));

    // ì˜¤íƒ ë°©ì§€: "ëª©í‘œ" ë˜ëŠ” "target" í‚¤ì›Œë“œê°€ ìˆìœ¼ë©´ ë” ì‹ ë¢°
    const mentionsGoalWord = p.includes("ëª©í‘œ") || p.includes("target") || p.includes("íƒ€ê²Ÿ");

    const clarity =
      (mentionsDuck ? 0.25 : 0) +
      (mentionsTarget ? 0.30 : 0) +
      (mentionsSwim ? 0.20 : 0) +
      (enforcesJson ? 0.15 : 0) +
      (mentionsGoalWord ? 0.10 : 0);

    // í™•ë¥ ì ìœ¼ë¡œ ê²°ê³¼ê°€ ë‹¬ë¼ì§€ëŠ” ëŠë‚Œ(ë©´ì ‘ì—ì„œ "ë¶ˆì•ˆì •ì„±" ì„¤ëª…í•˜ê¸° ì¢‹ìŒ)
    const roll = Math.random();

    if (clarity >= 0.80) {
      return { raw: `{"action":"swim_to","target":"red_circle"}`, cmd: { action: "swim_to", target: "red_circle" }, clarity };
    }
    if (clarity >= 0.55) {
      // ë°˜ì¯¤ ì„±ê³µ: ê°€ë” wanderê°€ ì„ì´ëŠ” ìƒí™©
      if (roll < 0.65) {
        return { raw: `{"action":"swim_to","target":"red_circle"}`, cmd: { action: "swim_to", target: "red_circle" }, clarity };
      }
      return { raw: `{"action":"wander"}`, cmd: { action: "wander" }, clarity };
    }

    // ì‹¤íŒ¨: í˜•ì‹ ê¹¨ì§(í˜„ì‹¤ LLMì—ì„œ í”í•œ ì¼€ì´ìŠ¤) ì‹œë®¬
    if (roll < 0.5) {
      return { raw: `ì˜¤ë¦¬ê°€ ë¬¼ì‚´ì„ ë”°ë¼ ë‘¥ë‘¥ ë– ë‹¤ë‹™ë‹ˆë‹¤... (ì„¤ëª… í…ìŠ¤íŠ¸ê°€ ë‚˜ì˜´)`, cmd: null, clarity };
    }
    return { raw: `{"action":"wander"}`, cmd: { action: "wander" }, clarity };
  }

  // ===== Simulation Control =====
  function applyCommand(cmd) {
    if (!cmd) {
      duck.mode = "wander"; // ì‹¤íŒ¨ ì‹œì—” ê¸°ë³¸ ë°©í™©
      return;
    }
    if (cmd.action === "swim_to" && cmd.target === "red_circle") {
      duck.mode = "swim_to";
      duck.speed = 2.2;
      return;
    }
    if (cmd.action === "wander") {
      duck.mode = "wander";
      duck.speed = 1.6;
      return;
    }
    duck.mode = "wander";
  }

  function resetScene() {
    duck.x = pond.x + pond.size * 0.20;
    duck.y = pond.y + pond.size * 0.78;
    duck.vx = 0;
    duck.vy = 0;
    duck.wobble = 0;
    duck.mode = "idle";
    duck.speed = 1.8;

    runLocked = false;
    lastTs = null;
    if (animId) cancelAnimationFrame(animId);
    animId = requestAnimationFrame(tick);

    log("[console] Ready.\n- í”„ë¡¬í”„íŠ¸ë¥¼ ìˆ˜ì •í•œ ë’¤ Runì„ ëˆ„ë¥´ì„¸ìš”.");
    setStatus(true, "ëŒ€ê¸° ì¤‘", "ëª©í‘œ: ì˜¤ë¦¬ë¥¼ ë¹¨ê°„ ë™ê·¸ë¼ë¯¸ê¹Œì§€ ë³´ë‚´ê¸°");
  }

  function panic() {
    duck.mode = "panic";
    duck.speed = 3.0;
    setStatus(false, "ì˜¤ë¦¬ê°€ íŒ¨ë‹‰ ìƒíƒœì…ë‹ˆë‹¤", "Resetì„ ëˆ„ë¥´ê±°ë‚˜ Runìœ¼ë¡œ ë‹¤ì‹œ ì œì–´í•´ë³´ì„¸ìš”.");
  }

  function runOnce() {
    if (runLocked) return;
    runLocked = true;

    const userPrompt = promptEl.value;
    const result = simulatedLLM(userPrompt);

    // console output
    log(
`[Simulated LLM Output]
${result.raw}

[Debug]
clarity_score = ${result.clarity.toFixed(2)}
(ë†’ì„ìˆ˜ë¡ ëª©í‘œ/í˜•ì‹ì´ ëª…í™•í•˜ë‹¤ê³  ê°€ì •í•©ë‹ˆë‹¤.)`
    );

    if (!result.cmd) {
      setStatus(false, "ì‹¤íŒ¨: ì¶œë ¥ í˜•ì‹/ëª©í‘œê°€ ì• ë§¤í•©ë‹ˆë‹¤", "JSONë§Œ ì¶œë ¥ + ëª©í‘œ(red_circle) + swim_toë¥¼ ëª…í™•íˆ ì ì–´ë³´ì„¸ìš”.");
      applyCommand(null);
    } else if (result.cmd.action === "swim_to") {
      setStatus(true, "ì‹¤í–‰: swim_to red_circle", "ì˜¤ë¦¬ê°€ ëª©í‘œë¡œ ì´ë™ ì¤‘ì…ë‹ˆë‹¤â€¦");
      applyCommand(result.cmd);
    } else {
      setStatus(false, "ë¶€ë¶„ ì„±ê³µ: wander", "ëª©í‘œë¥¼ ë” ëª…í™•íˆ(â€˜ë¹¨ê°„ ë™ê·¸ë¼ë¯¸ = red_circleâ€™) ì§€ì‹œí•´ë³´ì„¸ìš”.");
      applyCommand(result.cmd);
    }

    // ì ì‹œ í›„ ë‹¤ì‹œ Run ê°€ëŠ¥
    setTimeout(() => { runLocked = false; }, 400);
  }

  // ===== Physics + Drawing =====
  function keepInsidePond() {
    const minX = pond.x + duck.r, maxX = pond.x + pond.size - duck.r;
    const minY = pond.y + duck.r, maxY = pond.y + pond.size - duck.r;
    duck.x = clamp(duck.x, minX, maxX);
    duck.y = clamp(duck.y, minY, maxY);
  }

  function stepDuck(dt) {
    // dt in seconds
    duck.wobble += dt * 6;

    if (duck.mode === "idle") {
      duck.vx *= 0.90;
      duck.vy *= 0.90;
    }

    if (duck.mode === "swim_to") {
      const dx = target.x - duck.x;
      const dy = target.y - duck.y;
      const d = Math.hypot(dx, dy) || 1;
      const ux = dx / d, uy = dy / d;
      duck.vx = ux * duck.speed * 60 * dt;
      duck.vy = uy * duck.speed * 60 * dt;
    }

    if (duck.mode === "wander") {
      // gentle random drift
      const drift = 0.65;
      duck.vx = duck.vx * 0.92 + (Math.random() - 0.5) * drift;
      duck.vy = duck.vy * 0.92 + (Math.random() - 0.5) * drift;
      // limit
      const v = Math.hypot(duck.vx, duck.vy);
      const vmax = duck.speed * 1.2;
      if (v > vmax) {
        duck.vx = duck.vx / v * vmax;
        duck.vy = duck.vy / v * vmax;
      }
    }

    if (duck.mode === "panic") {
      duck.vx = (Math.random() - 0.5) * 6;
      duck.vy = (Math.random() - 0.5) * 6;
    }

    duck.x += duck.vx;
    duck.y += duck.vy;
    keepInsidePond();

    // success check
    const dToTarget = dist(duck.x, duck.y, target.x, target.y);
    if (dToTarget <= target.r + duck.r * 0.55) {
      if (duck.mode === "swim_to") {
        duck.mode = "idle";
        setStatus(true, "ì„±ê³µ! ì˜¤ë¦¬ê°€ ëª©í‘œì— ë„ì°©í–ˆìŠµë‹ˆë‹¤ ğŸ", "ì¢‹ìŠµë‹ˆë‹¤. ì´ í”„ë¡¬í”„íŠ¸ëŠ” â€˜ëª©í‘œ/í˜•ì‹â€™ì´ ì˜ ë‹«í˜”ìŠµë‹ˆë‹¤.");
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    // background vignette
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.beginPath();
    ctx.arc(W*0.35, H*0.25, 420, 0, Math.PI*2);
    ctx.fillStyle = "#7fb0ff";
    ctx.fill();
    ctx.restore();

    // pond (square)
    ctx.save();
    ctx.fillStyle = "rgba(70,130,255,0.20)";
    ctx.strokeStyle = "rgba(180,210,255,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(pond.x, pond.y, pond.size, pond.size, 16);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // water ripples
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = "#cfe3ff";
    for (let i=0;i<7;i++){
      const y = pond.y + 40 + i*48;
      ctx.beginPath();
      ctx.arc(pond.x + pond.size*0.45, y, 110 + i*6, 0.15*Math.PI, 0.85*Math.PI);
      ctx.stroke();
    }
    ctx.restore();

    // target red circle
    ctx.save();
    ctx.fillStyle = "rgba(255,60,80,0.85)";
    ctx.beginPath();
    ctx.arc(target.x, target.y, target.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 0.25;
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(255,80,100,0.9)";
    ctx.beginPath();
    ctx.arc(target.x, target.y, target.r + 10, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // duck (simple drawing)
    const bob = Math.sin(duck.wobble) * 2.2;
    const tilt = Math.sin(duck.wobble * 0.7) * 0.08;

    ctx.save();
    ctx.translate(duck.x, duck.y + bob);
    ctx.rotate(tilt);

    // shadow
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(0, duck.r + 8, duck.r*1.2, duck.r*0.45, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;

    // body
    ctx.fillStyle = "rgba(255,210,60,0.95)";
    ctx.beginPath();
    ctx.arc(0, 0, duck.r, 0, Math.PI*2);
    ctx.fill();

    // head bump
    ctx.fillStyle = "rgba(255,220,80,0.98)";
    ctx.beginPath();
    ctx.arc(-duck.r*0.35, -duck.r*0.55, duck.r*0.65, 0, Math.PI*2);
    ctx.fill();

    // beak
    ctx.fillStyle = "rgba(255,140,40,0.95)";
    ctx.beginPath();
    ctx.roundRect(duck.r*0.35, -duck.r*0.25, duck.r*0.7, duck.r*0.35, 6);
    ctx.fill();

    // eye
    ctx.fillStyle = "rgba(10,14,18,0.90)";
    ctx.beginPath();
    ctx.arc(-duck.r*0.55, -duck.r*0.62, 2.8, 0, Math.PI*2);
    ctx.fill();

    // small highlight
    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(-duck.r*0.35, -duck.r*0.15, duck.r*0.55, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();

    // labels
    ctx.save();
    ctx.fillStyle = "rgba(232,238,247,0.85)";
    ctx.font = "12px ui-monospace, Menlo, Consolas, monospace";
    ctx.fillText("POND", pond.x + 12, pond.y + 20);
    ctx.fillText("TARGET (red_circle)", target.x - 60, target.y - 28);
    ctx.fillText("DUCK", duck.x - 16, duck.y - 26);
    ctx.restore();
  }

  function tick(ts) {
    if (!lastTs) lastTs = ts;
    const dt = Math.min(0.05, (ts - lastTs) / 1000); // seconds
    lastTs = ts;

    stepDuck(dt);
    draw();
    animId = requestAnimationFrame(tick);
  }

  // ===== Events =====
  btnRun.addEventListener("click", runOnce);
  btnReset.addEventListener("click", () => {
    promptEl.value = basePrompt;
    resetScene();
  });
  btnHint.addEventListener("click", () => {
    // "Auto hint" inserts a strongly constrained instruction
    const add =
`\n\n[ì¶”ê°€ ì§€ì‹œ]\në°˜ë“œì‹œ ì•„ë˜ JSONë§Œ ì¶œë ¥í•˜ì„¸ìš”:\n{"action":"swim_to","target":"red_circle"}\nì„¤ëª… ë¬¸ì¥ ê¸ˆì§€. ë‹¤ë¥¸ ë‹¨ì–´ ê¸ˆì§€.\n`;
    promptEl.value = promptEl.value + add;
    setStatus(true, "íŒíŠ¸ ì ìš©ë¨", "Runì„ ëˆŒëŸ¬ ê²°ê³¼ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”.");
  });
  btnPanic.addEventListener("click", panic);

  // ===== Start =====
  // polyfill for roundRect if needed
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
      const rr = Array.isArray(r) ? r : [r, r, r, r];
      const [r1, r2, r3, r4] = rr;
      this.beginPath();
      this.moveTo(x + r1, y);
      this.lineTo(x + w - r2, y);
      this.quadraticCurveTo(x + w, y, x + w, y + r2);
      this.lineTo(x + w, y + h - r3);
      this.quadraticCurveTo(x + w, y + h, x + w - r3, y + h);
      this.lineTo(x + r4, y + h);
      this.quadraticCurveTo(x, y + h, x, y + h - r4);
      this.lineTo(x, y + r1);
      this.quadraticCurveTo(x, y, x + r1, y);
      this.closePath();
      return this;
    };
  }

  resetScene();
})();
</script>
</body>
</html>
